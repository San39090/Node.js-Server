This Node.js application is designed to create a simple yet functional HTTP server using the core modules provided by Node.js—namely, http, fs, and path. The primary goal of this server is to handle basic routing and serve static HTML files to users depending on the URL they access in the browser. All the HTML files required by the server are stored in a folder named public, which is located in the same directory as the script. To ensure platform-independent file paths, the script uses path.join(__dirname, 'public') to create an absolute path to the public directory. When a request is received by the server, it checks the URL path from the incoming request using req.url. If the user visits the root route (i.e., /), the server will respond with the home.html file. If the request is for /about, it returns about.html, and if the path is /contact, it returns contact.html. The server constructs the path to the correct file based on the URL and tries to read the file using fs.readFile().
If the requested file is found and successfully read from the file system, the server sets the response header to indicate a successful request (200 OK) and sends back the contents of the HTML file with the Content-Type set to text/html. However, if an error occurs while reading the file—for example, if the file doesn’t exist—the server doesn't stop or throw a raw error. Instead, it catches the error and attempts to serve a custom 404.html file located in the same public directory. This custom 404 page ensures that users get a meaningful and user-friendly error message instead of a blank or technical error response. This logic is implemented inside the error-handling section of the fs.readFile() callback. The server then continues its operation, ready to handle the next request.
Finally, the server listens for incoming requests on port 3000, and once it is successfully running, it logs a confirmation message to the console that says "Server is running on port 3000". This helps the developer know that the server has started without issues. This kind of setup is often used as a foundational exercise when learning how to build web servers in Node.js, as it introduces key concepts such as routing, file handling, serving static content, and basic error management without relying on third-party libraries like Express. Although simple, this project lays the groundwork for more complex server-side applications and gives a clear understanding of how Node.js handles HTTP requests and file system interactions.
